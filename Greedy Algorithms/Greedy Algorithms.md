# 贪心算法

***

引入：对于大部分最优化问题，使用动态规划来求最优解有点浪费，可以使用更加高效、简单的算法——贪心算法。

> 贪心算法在每一步的选择中，都选择当时最佳的情况。它并不能保证得到最优解，但是很多问题确实可以求得最优解。

## Part 1 活动选择问题

***

有n个活动的集合S={a1,a2,...,an}，这些活动使用同一个资源(如同一个教室)，但它同时只能提供给一个活动，每个活动有一个**开始时间** *si* 和**结束时间** *fi*，任务ai发生在半开区间 [*si,fi*)。

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98(1).jpg)

### 1. 用动态规划方法

*c[i,j]*表示最优解的集合的大小。
则得到递归式：***c[i,j]=c[i,k]+c[k,j]+1***
如果不知道 ***sij*** 的最优解包含 ***ak*** ，则：

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98(2).jpg)

### 2. 贪心算法

**1. 最优子结构**
   令*Sij*表示在*ai*结束之后开始，且在*aj*开始之前结束的那些活动的集合,其最优解*Aik*已知包含活动*ak*,则对其子问题*Sik*和*Skj*的最优解*Aik*和*Akj*，有*Aij=Aik∪{ak}∪Akj*。

> 反证法：若存在|*Aij'*|>|*Aij*|,即存在|*Aik'*|+|*Akj'*|+1>|*Aik*|+|*Akj*|+1,与*Aik*,*Akj*为最优解相矛盾。

**2. 贪心选择**
   选择一个活动使得选出它后剩下的资源能被尽量多的其他任务所用。根据直觉，我们首选的活动应该是S中最早结束的活动。



#### 伪代码

**递归贪心算法**

```
RECURSIVE-ACTIVITY-SELECTOR(s,f,k,n)    
m=k+1
while m<=n and s[m]<f[k]
    m=m+1
if m <= n
    return {am} U RECURSIVE-ACTIVITY-SELECTOR(s,f,m,n)
else return empty
```

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9%E9%97%AE%E9%A2%98(3).jpg)



**迭代贪心算法**

```
GREEDY-ACTIVITY-SELECTOR(s,f)
n=s.length
A={a1}
k=1
for m=2 to n
    if s[m]>=f[k]
        A=A U {am}
        k=m
return A
```

## Part 2 贪心算法原理

***

**步骤：**

1. 将最优化问题转换为这样的形式：对其做出一些选择后，只剩下一个子问题需要求解。
2. 证明做出贪心选择后原问题总是存在最优解，即贪心选择总是安全的。
3. 证明做出贪心选择后剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构。
   
   

**1. 贪心选择性质**
可以通过做出局部最优解来构建全局最优解，而不用考虑子问题的解。

> 贪心算法进行选择时可能依赖之前做出的选择，但不依赖任何将来的选择或是子问题的解。

**2. 最优子结构**
一个问题的最优解能够包含其子问题的最优解。

> 这个性质是能否应用动态规划和贪心算法的关键要素。

#### 贪心算法和动态规划的微小差别

可以通过两个相似问题的比较来进行分辨。

1. 0-1背包问题(动态规划)
   
   > 只能对商品完整的拿取或留下。(金条)

2. 分数背包问题(贪心算法)
   
   > 对商品可以只拿走一部分。(金砂)
   
   其中第 *i* 个商品价值 *vi* 美元，重 *wi* 磅，背包最多容纳 W 磅重的商品。*vi,wi* 都是整数。

## Part3 赫夫曼编码

***

**考虑二进制编码**

1. 定长编码
    每个字符的编码长度相同。

2. 变长编码
    对高频字符赋予短码，低频字符赋予长码。
   
   > 使用**前缀码** (即没有如何码字是其他码字的前缀)，可以保证达到最优数据压缩率，也不会使编码丧失一般性，使编码文件的开始部分无歧义。

对于一个文件，最优的编码方案总是一颗**满二叉树**。

### 构造赫夫曼编码

```
HUFFMAN(C)
n=|C|
Q=C
for i=1 to n-1
    allocate a new node z
    z.left=x=EXTRACT-MIN(Q)//寻找Q中频率最低的数作为左孩子
    z.right=y=EXTRACT-MIN(Q)
    z.freq=x.freq+y.freq
    INSERT(Q,z)
return EXTRACT-MIN(Q)
```

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81(1).jpg)

#### 判断正确性

要证明赫夫曼编码是正确的，就要证明最优前缀码具有**贪心选择**和**最优子结构**性质。

**证明贪心选择**

**引理：** 给定一个字母表*C*，每个字符*c*的频率为*c.freq*，若*x*和*y*是*C*中频率最低的两个字符，则存在一个*C*的最优前缀码，其中*x*和*y*的码字长度相同，且只有最后一个二进制位不同。



![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81(3).jpg)



![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81(2).jpg)



**证明最优子结构**

给定一个字母表 C ，每个字符*c*的频率为*c.frep*，若*x*和*y*是 C 中频率最低的两个字符，定义字符*z*且*z.frep = x.frep + y.frep*，定义字母表 C"=( C - {*x,y*})U{*z*}，字母表 C 的任一最优前缀无关编码对应的一棵二叉树 T' ，将 T' 中的字符*z*对应的叶结点修改为一个内部结点且两个孩子结点分别为字符*x*和*y*对应的叶结点，这样可以得到字母表 C 的某一最优前缀无关编码对应的一棵二叉树 T。

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E8%B5%AB%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81(4).jpg)



## Part4 离线缓存

***

**缓存**：容量比主存小，速度比主存快的**存储器**。
计算机通过把需要访问的数据的一部分储存在缓存中，可以减少数据的访问时间。缓存将数据有组织地存放在**缓存块**中，缓存块大小一般是32、64或128字节

**主存**：虚拟内存系统中，主内存可以被视为驻留在磁盘上的数据的缓存。这些主存块被称为页，页大小一般是4096字节。

当一个程序执行时，需要进行一系列的存储器请求。假设有*n*个访存请求，这些数据按照请求顺序分别在*b1,b2,...,bn*块中。事实上，这些请求不会完全不同，多个请求有可能需要访问同一个块。

当需要访问*bi*时，会出现以下三种情况：

**情况一**：由于之前访问过*bi*，*bi*已经在缓存中，当需要再次访问*bi*时，可以直接访问缓存，称为**缓存命中**。
**情况二**：*bi*不在缓存中，缓存未满，当需要访问*bi*时，直接将*bi*填充到空闲的缓存块。
**情况三**：*bi*不在缓存中，缓存已满，当需要访问*bi*时，需要预先将某一个缓存块空出来，然后将*bi*填充到空闲的缓存块。

情况二和情况三称为**缓存未命中**。情况二称为**强制未命中**。

一般情况下，由于计算机无法知道未来的请求，因此缓存是一个在线问题。这里我们仅仅考虑缓存问题的离线版本，即已知完整的访存请求序列和缓存块数量，我们的目标是最小化缓存未命中，最大化缓存命中。

我们采用称为**将来最久**的贪心策略求解离线缓存问题，即如果缓存已满，那么选择已在缓存中且访存序列中将来最久到达的块进行置换。

#### 离线缓存的最优子结构

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98(1).jpg)

#### 离线缓存的贪心选择性质

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98(2).jpg)

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98(3).jpg)

我们将用归纳法证明这些性质适用于每个请求.

1. 对于*j=i+1,...,m*，归纳基础为C*S,j*和C*S',j*完全相同。对于需要请求 *bi*，S移除缓存块*z*，S'移除缓存块*x*，C*S,i+1*和C*S,i+1*至多有一个缓存块不同。若C*S,i+1*和C*S',i+1*不同，则C*S,i+1*=D*i+1*∪{*z*}且C*S',i+1*=D*i+1*∪{*x*}，其中*x≠z*。归纳步骤将证明S'在请求*bj*下如何运行，其中*i+1 <= J <= m-1*。归纳假设请求*bj*后性质1能够保持。由于*z=bm*为C*S,i*中将来最久被请求的缓存块，已知*bj≠z*。我们考虑以下几种情况：

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98(4).jpg)

2. 在上述关于保持性质1的讨论中，S 只在前两种情况可能出现缓存命中，S'只有在缓存 S 命中的情况下才可能缓存命中。

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98(5).jpg)

![](file:///C:/Users/22389/Desktop/%E5%AD%A6%E4%B9%A0/Turing/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/%E7%A6%BB%E7%BA%BF%E7%BC%93%E5%AD%98(6).jpg)
